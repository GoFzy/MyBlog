# 浏览器的多进程机制
## 进程与线程的概念
* 进程: `CPU`资源分配的最小单位
* 线程: `CPU`调度的最小单位

## 浏览器中常见的进程
浏览器是多进程的，常见的进程如下:
1. **主控**进程，只有一个，负责调度，管理整个浏览器的运行
2. **渲染**进程，也称**浏览器内核**，每一个 `tab` 页一个，负责页面渲染，`js` 执行等
3. **第三方插件**进程，浏览器开启的第三方插件
4. `GPU`进程，只有一个，用于 `3D` 绘制

## 浏览器的渲染进程
浏览器渲染进程也称浏览器内核，在这个进程内会进行页面的渲染、`JS` 的执行以及事件循环，因此浏览器渲染进程又是**多线程**的，具体包括如下线程:  
![browser_inner_thread](https://raw.githubusercontent.com/GoFzy/pic-bed/master/browser_inner_thread.png)  
<h4>GUI渲染线程</h4>

* 负责渲染浏览器界面，解析`HTML`，`CSS`，构建 `DOM` 树、`CSS`规则树并生成 `Render` 树，最后进行布局和绘制等。
* 当界面需要重绘（`Repaint`）或由于某种操作引发回流( `Reflow` )时，该线程就会执行
* 注意，`GUI` 渲染线程与 `JS` 引擎线程是互斥的

<h4>JS引擎线程</h4>  

* 也称为JS内核，负责处理 `JS` 脚本程序（例如V8引擎），一个 `tab` 页只有一个该线程用来执行`JS`（单线程）
* 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞

<h4>事件触发线程</h4>

* 归属于浏览器而不是JS引擎，用来控制事件循环
* 当 `JS` 引擎执行代码块如定时器、`AJAX` 请求时，会在相应线程处理完成后将对应回调任务添加到事件线程中
* 当 `JS` 引擎空闲时，该线程会把事件添加到待处理队列的队尾，让 `JS` 引擎的处理
* 注意，由于 `JS` 的**单线程**关系，所以这些待处理队列中的事件都得排队等待 `JS` 引擎处理（当`JS` 引擎空闲时才会去执行）

<h4>定时触发器线程</h4>

* 传说中的 `setInterval` 与 `setTimeout` 所在线程
* 浏览器定时计数器并不是由 `JS` 引擎计数的,（因为 `JS` 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
* 通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 `JS` 引擎空闲后执行）

<h4>异步http请求线程</h4>

* 在`XMLHttpReques`t在连接后是通过浏览器新开一个线程请求，具体来说就是在 `send` 方法调用后开启
* 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 `JS` 引擎执行


## GUI渲染线程工作流程
浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：
* 解析 `HTML` 生成 `DOM` 树
* 解析 `CSS` 生成 `CSS` 规则树
* 将 `CSS` 规则树与 `DOM` 树合并成 `Render` 树
* 布局`Render` 树（`Layout/reflow`），负责各元素尺寸、位置的计算
* 绘制 `Render` 树（`paint`），绘制页面像素信息，并显示在屏幕上

渲染完毕后就是`window.onload` 事件了，之后就是自己的 `JS` 逻辑处理了，具体流程可以参考下图进行理解
![browser_rending](https://raw.githubusercontent.com/GoFzy/pic-bed/master/browser_rending.png)

## JS引擎线程解析流程
<h3>预处理阶段</h3>

首先在 `js` 解析执行前，会有一个**预处理**阶段，这里仅提部分内容:  

**1. 分号补全**  
* 当有换行符（包括含有换行符的多行注释），并且下一个 `token` 没法跟前面的语法匹配时，会自动补分号
* 当有}时，如果缺少分号，会补分号
* 程序源代码结束时，如果缺少分号，会补分号

例如
```js
function b() {
  return
  {
    a: 'a'
  };
}
```
由于分号补全机制，所以它变成了：
```js
function b() {
    return;
    {
        a: 'a'
    };
}
```
所以运行后是`undefined`

**2. 变量提升**  
一般包括**函数提升**和**变量提升**，这里不展开只说结论，详情可以参看[该篇文章](https://juejin.im/post/5a0e3577f265da43085d978b)
* **使用 `var` 定义变量的时候，`js` 解释器会将变量提升到该作用域的最顶部，这就是变量提升**
* **函数的提升只对声明式函数有效，对字面量函数无效，且函数会被优先放在顶部，而后才是变量**

<h3>解析阶段</h3>

在解析阶段，V8引擎分为以下几个模块对源码进行处理:
* `Parser`：通过分词和语法分析将 `JS` 源码转换成 `AST(Abstract Syntax Tree)` 语法树(`babel`就是通过替换 `AST` 语法树实现 `ES6` 到 `ES5` 的转换)
* `Ignition`：解释器，负责将 `AST` 语法树解释成 `bytecode` 字节码
* `Turbofan`： 编译器，负责将 `bytecode` 字节码转换成汇编代码

除此以外，V8引擎中还有个 `Orinoca` **垃圾回收模块**，清除方法分为以下两种：
* 标记清除: 遍历所有可访问的对象，回收已不可访问的对象
* 引用次数：跟踪记录每个值被引用的次数，回收次数为0的对象